# -*- coding: utf-8 -*-
"""24.K-Fold Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17WCmM1MTaM0xfPy_T_ISsc-GgZy1Uf6v

# **K-Fold Algorithm**
"""

# importing libraries
from sklearn.cluster import KMeans #k-mean algorithm
from sklearn.preprocessing import MinMaxScaler #to scale the feature values for proper plotting
import pandas as pd
import matplotlib.pyplot as plt

df=pd.read_csv('/content/income.csv')

df.head()

"""## **Initial Plot**"""

plt.scatter(df['Age'], df['Income($)'])

"""## **Applying K-Mean Clustering**"""

km=KMeans(n_clusters=3)
km

#fit() only learns from the data — it calculates the minimum and maximum values of the column (for MinMaxScaler).
#transform() actually applies the scaling formmula on the data to scale it.
y_pred=km.fit_predict(df[['Age','Income($)']])
y_pred

# appending the output column in the dataset
df['Cluster']=y_pred
df.head()

df1=df[df.Cluster==0]
df2=df[df.Cluster==1]
df3=df[df.Cluster==2]

"""## **Plotting the Clusters**

---

notice that the plotting is not accurate, its becuase the data points haven't been scaled yet

"""

plt.scatter(df1.Age,df1['Income($)'],color='green')
plt.scatter(df2.Age,df2['Income($)'],color='red')
plt.scatter(df3.Age,df3['Income($)'],color='blue')

plt.xlabel('Age')
plt.ylabel('Income($)')
plt.show()

"""## **Scaling the Data**"""

scaler=MinMaxScaler()
df['Income($)'] = scaler.fit_transform(df[['Income($)']])
df['Age'] = scaler.fit_transform(df[['Age']])
df

# applying k means again on the scaled data now
km=KMeans(n_clusters=3)
y_pred=km.fit_predict(df[['Age','Income($)']])
y_pred

df['Cluster']=y_pred
df.head()

df1=df[df.Cluster==0]
df2=df[df.Cluster==1]
df3=df[df.Cluster==2]

# computing centroids
km.cluster_centers_

plt.scatter(df1.Age,df1['Income($)'],color='green')
plt.scatter(df2.Age,df2['Income($)'],color='red')
plt.scatter(df3.Age,df3['Income($)'],color='blue')

# km.cluster_centers_[:, 0] → all x-coordinates
# km.cluster_centers_[:, 1] → all y-coordinates
plt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1], color='black', marker='*', label='Centroid')

plt.xlabel('Age')
plt.ylabel('Income($)')

plt.show()

k_rng=range(1,10) #setting the range of k from 1 to 9
sse=[] #making array for sum of squared error
for k in k_rng:
  km=KMeans(n_clusters=k)
  km.fit_predict(df[['Age','Income($)']]) #training with with cluster numbers
  sse.append(km.inertia_) #inertia_ is a built in function to compute sse

sse

"""### **Plotting SSE with different K values (Elbow Method)**"""

plt.xlabel('K')
plt.ylabel('Sum of Square Error (SSE)')
plt.plot(k_rng,sse)

